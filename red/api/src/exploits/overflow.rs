use axum::{Json, http::StatusCode, response::IntoResponse};
use serde_json::json;
use std::time::Duration;
use tracing::info;

// 1GB
const CHUNK_SIZE_TO_ALLOCATE: usize = 1000 * 1024 * 1024;

pub async fn overflow_memory() -> impl IntoResponse {
    let mut allocations = Vec::new();

    // will allocate a total of 50GB (50 * 1GB)
    for _ in 0..50 {
        unsafe {
            let ptr = libc::malloc(CHUNK_SIZE_TO_ALLOCATE);
            if ptr.is_null() {
                info!("Memory allocation failed");
                break;
            }

            // Optional: touch the memory to ensure itâ€™s actually allocated
            libc::memset(ptr, 0, CHUNK_SIZE_TO_ALLOCATE);

            allocations.push(ptr);
        }

        info!("Allocated {} MiB", CHUNK_SIZE_TO_ALLOCATE / (1024 * 1024));
        std::thread::sleep(Duration::from_millis(500));
    }

    (
        StatusCode::OK,
        Json(json!({
            "message": "Memory overflow attack simulated successfully",
        })),
    )
}
